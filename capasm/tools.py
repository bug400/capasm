#!/usr/bin/python3
# -*- coding: utf-8 -*-
#
# This module contains the following tools for the CAPASM assembler:
# - mklex75: adds the necessary header information to a generate a HP-75
#   lex file from a binary object file generated by CAPASM.
# - static methods to support regression testing
# (c) 2020 Joachim Siebold
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#--------------------------------------------------------------------------
#
# Changelog
# 18.05.2020 jsi:
# - start change log
# 19.05.2020 jsi
# - added clsSymClassGenerator class
# - added capglo entry point
# - removed main entry point
# 22.05.2020 jsi
# - raise custom exception on fatal error
#
import sys, argparse,os, codecs
from pathlib import Path
from datetime import datetime
from .assembler import clsLineScanner, numParse, capasmError

#
# SymCassGenerator class -------------------------------------------------
#
# An object of this class reads a global symbol file which must match
# the syntax rules of the CAPASM assembler. Only comments, DEF and EQU
# statements are allowed in this file.
#
# The object generates a Python script which a static class "globalSymbols"
# to access global symbols for a specific machine. At the moment CAPASM 
# supports the script file names # globals75.py, globals85.py, globals87.py. 
# The -m option of the assembler controls which file is used for the assembly.
#
# The program checks for duplicate global symbol definitions which exist
# in the globals85.txt and globals75.txt. At the moment duplicate
# definitions overwrite an existing definition. The reason for duplicate
# entries is under investigation.
#
class clsSymClassGenerator(object):

   SYM_EQU=0
   SYM_DAD=1

   def __init__(self):
      super().__init__()

   def generate(self,inputFileName,outputFileName):

      lineScanner=clsLineScanner()
      symDict= { }
      duplicates=0
      errors=0
      print("")
      print("Processing file "+str(inputFileName))
      infile=codecs.open(inputFileName,"r",encoding="ISO-8859-1",errors="ignore")
     
      outfile=open(outputFileName,"w")
#
#     Write global symbol class definition
#
      outfile.write("#!/usr/bin/python3\n# -*- coding: utf-8 -*-\n")
      outfile.write("#\n# Global symbols from file "+str(inputFileName)+"\n")
      outfile.write("# Autogenerated file, do not modify!\n")
      outfile.write("#\n")
      outfile.write("class globalSymbols():\n")
      outfile.write("\n")
      outfile.write("   symbols= {\n")
#
#     Process lines
#
      lineCount=0
      while True:
         line=infile.readline()
         if not line:
            break
         line=line.strip("\r\n")
         lineCount+=1
#
#        Scan line, we get a list of token:
#        - lineNumber (inserted, if no linenumber in the source file)
#        - label
#        - opcode
#        - list of operands which should consist only of the symbol value 
#
         scannedLine=lineScanner.scanLine(lineCount,line)
         lineNumber=scannedLine[0].string
#
#        Empty line
#
         if scannedLine[1]==None:
            continue
#
#        Comment
#
         symbolName=scannedLine[1].string
         if symbolName[0]=="*" or symbolName=="!":
            continue
#
#        Check opcode, only "EQU" and "DAD" are allowed
#
         opCode= scannedLine[2].string
         if opCode is None:
            print("missing opcode at line: ",lineNumber)
            errors+=1
            continue
         if opCode== "EQU":
            opTyp=clsSymClassGenerator.SYM_EQU
         elif opCode == "DAD":
            opTyp=clsSymClassGenerator.SYM_DAD
         else:
            print("illegal opcode at line: ",lineNumber)
            errors+=1
            continue
#
#        Check value which must be a valid number
#
         if len(scannedLine[3])!=1:
            print("illegal label value at line: ",lineNumber)
            errors+=1
            continue
         value=scannedLine[3][0].string
         intValue=numParse.parseNumber(value)
         if intValue==None:
            print("illegal label value at line: ",lineNumber)
            errors+=1
            continue
#
#        Check and print duplicates
#
         if symbolName in symDict.keys():
            print("Line: "+lineNumber+": "+line)
            ret=symDict[symbolName]
            print("symbol redefined, first definition was at line: "+ \
                  ret[0]+" opcode: "+ret[1]+" value: "+ret[2])
            outfile.write('      "'+symbolName+'" : ['+str(opTyp)+ \
                    ","+str(intValue)+"],\n")
            duplicates+=1
         else:
            symDict[symbolName]=[lineNumber,opCode,value]
            outfile.write('      "'+symbolName+'" : ['+str(opTyp)+ \
                    ","+str(intValue)+"],\n")
#
#     All input line processed, write access method
#
      infile.close()
      outfile.write("   }\n")
      outfile.write("   @staticmethod\n")
      outfile.write("   def get(name):\n")
      outfile.write("      if name[0]=='=':\n")
      outfile.write("         name=name[1:]\n")
      outfile.write("      if name in globalSymbols.symbols.keys():\n")
      outfile.write("         return globalSymbols.symbols[name]\n")
      outfile.write("      else:\n")
      outfile.write("         return None\n")
      outfile.write("\n")
      outfile.close()
      print("Errors {:d}, duplicate entries {:d} ".format(errors,duplicates))
#
# Static class for the comparision of binary files
#
class binDiff(object):

   @staticmethod
   def compare(fileName1,fileName2):
      try:
         name=fileName1
         f=open(name,"rb")
         content1=f.read()
         f.close()
         name=fileName2
         f=open(name,"rb")
         content2=f.read()
         f.close()
      except (OSError,FileNotFoundError):
         print("Can not read binary file: "+str(name))
         return None
      len1=len(content1)
      len2=len(content2)
      numCompare=min(len1,len2)
      diffs=[]
      for i in range(0,numCompare):
         if content1[i]!= content2[i]:
            diffs.append(i)
      return [len(diffs),len1,len2,diffs]

#
# Date/Time for the LIF file header as BCD
#
class clsDateTime(object):

   def __init__(self):
      super().__init__()
      now=datetime.now()
      self.bcdYear= self.intToBcd(now.date().year-2000)
      self.bcdMonth= self.intToBcd(now.date().month)
      self.bcdDay= self.intToBcd(now.date().day)
      self.bcdHour= self.intToBcd(now.time().hour)
      self.bcdMin= self.intToBcd(now.time().minute)
      self.bcdSec= self.intToBcd(now.time().second)

   def intToBcd(self,value):
      return (((int(value/10)%10)<<4)+(value%10))
#
# Base class
#
class clsBinaryItem(object):
   def __init__(self):
      super().__init__()
      self.objectCode= None

   def getBytes(self):
      return self.objectCode

   def getLen(self):
      return len(self.objectCode)
#
# Class that implements the object code
#
class clsObjectFile(clsBinaryItem):

   def __init__(self,filename):
      super().__init__()
      try:
         f=open(filename,"rb")
         self.objectCode=f.read()
         f.close()
      except OSError:
         raise capasmError("Can not read binary object file")
#
# Class that implements the LIF file header
#
class clsLifHeader(clsBinaryItem):

   def __init__(self,length,filename,isRegressionTest):
      super().__init__()
      dt=clsDateTime()
      self.objectCode=bytearray(32)
      i=0
      for c in filename:        # LIF file name
         self.objectCode[i]=ord(c)
         i+=1
      self.objectCode[8]=0x20   # pad file name
      self.objectCode[9]=0x20
      self.objectCode[10]=0xE0  # LIF 75
      self.objectCode[11]=0x89
      length+=18                # length in bytes including HP-75 file header
      length+=255               # calculate length in blocks
      self.objectCode[16]=0 
      self.objectCode[17]= (length >> 24) & 0xFF
      self.objectCode[18]= (length >> 16) & 0xFF
      self.objectCode[19]= (length >> 8) & 0xFF
      if not isRegressionTest:
         self.objectCode[20]=dt.bcdYear
         self.objectCode[21]=dt.bcdMonth
         self.objectCode[22]=dt.bcdDay
         self.objectCode[23]=dt.bcdHour
         self.objectCode[24]=dt.bcdMin
         self.objectCode[25]=dt.bcdSec
      self.objectCode[26]=0x80  # Implementing bytes
      self.objectCode[27]=0x01
      self.objectCode[28]=0x20  
      self.objectCode[29]=0x20
      self.objectCode[30]=0x20
      self.objectCode[31]=0x20
      
#
#  Class that implements the HP-75 file system header
#
class clsFileHeader(clsBinaryItem):

   def __init__(self,length,filename):
      super().__init__()
      self.objectCode=bytearray(18)
      length=length+18          # length of file including header
      low= length & 0xFF
      high= length >> 8
      self.objectCode[2]=low
      self.objectCode[3]=high
      self.objectCode[4]=0x8D   # access bits, fake
      self.objectCode[5]=0x4C   # "L"
      self.objectCode[6]=0xC7   # date and time faked
      self.objectCode[7]=0xBA
      self.objectCode[8]=0x7F
      self.objectCode[9]=0xA0
      i=10
      for c in filename:
         self.objectCode[i]=ord(c)
         i+=1
#
# Make (internal) LIF and HP-75 compatible file name
#
def makeLifFileName(fName):
   fName=fName.upper()
   if len(fName)> 8:
      raise capasmError("LIF filename exceeds 8 characters")
   if not fName.isalnum() or not fName[0].isalpha():
      raise capasmError("illegal LIF file name")
   fName=fName.ljust(8)
   return fName

class clsLifFileCreator(object):

   def __init__(self):
      super().__init__()

   def create(self,binFileName,lexFileName="",lifFileName=""):
#
#     check if we run in regression test mode
#
      isRegressionTest=True
      if os.getenv("CAPASMREGRESSIONTEST"):
         isRegressionTest=True
#
#     build name of lex file if not specified
#
      if lexFileName=="":
         lexFileName=str(Path(binFileName).with_suffix(".lex"))
#
#     build the (internal) LIF file name, if not specified
#
      if lifFileName=="":
         fname=str(Path(lexFileName).stem)
      else:
         fname=lexFileName
      lifFileName=makeLifFileName(fname)
#
#     read object file into memory
#
      objectFile=clsObjectFile(binFileName)
#
#     create file header
#
      fileHeader=clsFileHeader(objectFile.getLen(),lifFileName)
#
#     create LIF file header
#
      lifHeader=clsLifHeader(objectFile.getLen(),lifFileName,isRegressionTest)
#
#     write file
#
      try:
         lexFile=open(lexFileName,"wb")
         lexFile.write(lifHeader.getBytes())
         lexFile.write(fileHeader.getBytes())
         lexFile.write(objectFile.getBytes())
         lexFile.close()
      except OSError:
         print("cannot write lex file")
      print("HP-75 lex file "+lexFileName+" created with LIF file name " \
          + lifFileName)

def mklex75():        # pragma: no cover
#
#  command line arguments processing
#
   argparser=argparse.ArgumentParser()
   argparser.add_argument("binfile",help="binary object code file")
   argparser.add_argument("-l","--lexfile",help="lex output file",default="")
   argparser.add_argument("-f","--filename",help="LIF file name of lex file",default="")
   args= argparser.parse_args()

   l=clsLifFileCreator()
   try:
      l.create(args.binfile,args.lexfile,args.filename)
   except capasmError as e:
      print(e.msg+" -- program terminated")
      sys.exit(1)

def capglo():         # pragma: no cover

   p=argparse.ArgumentParser()
   p.add_argument('inputfiles',nargs='+',help="list of gobal symbol assembler files")
   args=p.parse_args()

   gen=clsSymClassGenerator()
   for fileName in args.inputfiles:
      inf=Path(fileName)
      of=inf.with_suffix(".py")
      try:
         gen.generate(fileName,str(of))
      except capasmError as e:
         print(e.msg+" -- program terminated")
         sys.exit(1)
      
